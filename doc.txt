2. Các bước triển khai Worker Pool trong Golang
2.1 Định nghĩa hàm worker
- Hàm worker lắng nghe trên channel jobs, xử lý công việc rồi gửi kết quả lại qua results:

func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        fmt.Println("Worker", id, "started job", job)
        time.Sleep(time.Second) // Giả lập công việc
        fmt.Println("Worker", id, "finished job", job)
        results <- job * 2 // Gửi kết quả
    }
}

2.2 Tạo các channel
- Trong hàm main, tạo channel cho job và kết quả:

jobs := make(chan int, 5)     // Hàng đợi công việc
results := make(chan int, 5)  // Hàng đợi kết quả

2.3 Khởi tạo các worker Goroutines
- Khởi chạy số lượng worker cố định:

for w := 1; w <= 3; w++ {
    go worker(w, jobs, results)
}

2.4 Gửi công việc vào queue
- Dùng vòng lặp để gửi dữ liệu công việc, sau đó đóng channel:

for j := 1; j <= 5; j++ {
    jobs <- j
}
close(jobs)

2.5 Thu thập kết quả
- Tiếp tục nhận kết quả từ results:

for a := 1; a <= 5; a++ {
    <-results
}
close(results)

* Ví dụ đầy đủ:

package main

import (
    "fmt"
    "time"
)

func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        fmt.Println("Worker", id, "started job", j)
        time.Sleep(time.Second)
        fmt.Println("Worker", id, "finished job", j)
        results <- j * 2
    }
}

func main() {
    const numJobs = 5
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)

    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }

    for j := 1; j <= numJobs; j++ {
        jobs <- j
    }
    close(jobs)

    for a := 1; a <= numJobs; a++ {
        <-results
    }
    close(results)
}


* Kết quả mẫu:

Worker 3 started job 1
Worker 1 started job 2
Worker 2 started job 3
Worker 1 finished job 2
Worker 1 started job 4
Worker 3 finished job 1
Worker 3 started job 5
Worker 2 finished job 3
Worker 1 finished job 4
Worker 3 finished job 5