5. recover - Lấy lại quyền kiểm soát từ một `panic`**
5.1. recover là gì?
- recover là một hàm tích hợp sẵn, cho phép chúng ta "bắt" lại một `panic` và lấy lại quyền kiểm soát luồng thực thi, ngăn không cho chương trình bị crash.
* Quy tắc vàng: recover chỉ có hiệu lực khi được gọi trực tiếp bên trong một hàm defer. Nếu được gọi ở nơi khác, nó sẽ không làm gì cả và trả về `nil`.

5.2. Cách hoạt động
-  Khi một panic xảy ra, Go sẽ bắt đầu thực thi các hàm defer.
-  Nếu một trong các hàm defer đó gọi recover(), recover sẽ "bắt" lấy giá trị được truyền vào panic và dừng lại quá trình "unwinding".
-  Chương trình sẽ tiếp tục thực thi từ sau điểm defer đó.

5.3. Ví dụ về recover
- Bây giờ, chúng ta sẽ viết một hàm bao bọc để gọi `fullName` một cách an toàn.

    package main

    import "fmt"

    // Hàm fullName giữ nguyên như ví dụ trước
    func fullName(firstName *string, lastName *string) {
        if firstName == nil {
            panic("runtime error: first name cannot be nil")
        }
        if lastName == nil {
            panic("runtime error: last name cannot be nil")
        }
        fmt.Printf("%s %s\n", *firstName, *lastName)
    }

    // handleFullName là hàm bao bọc an toàn
    func handleFullName() {
        // Dùng defer và một hàm ẩn danh để bắt panic
        defer func() {
            // recover() sẽ bắt được giá trị của panic
            if r := recover(); r != nil {
                fmt.Println("ĐÃ BẮT ĐƯỢC LỖI:", r)
            }
        }()

        fmt.Println("Bắt đầu gọi fullName...")
        firstName := "Elon"
        // Gây ra panic một cách có chủ đích
        fullName(&firstName, nil) 
        
        // Dòng này sẽ không được thực thi vì panic xảy ra trước đó
        fmt.Println("Kết thúc gọi fullName (bình thường)") 
    }

    func main() {
        handleFullName()
        // Chương trình vẫn tiếp tục chạy đến đây!
        fmt.Println("Chương trình chính đã kết thúc một cách an toàn.")
    }
    
    Kết quả khi chạy:
    Bắt đầu gọi fullName...
    ĐÃ BẮT ĐƯỢC LỖI: runtime error: last name cannot be nil
    Chương trình chính đã kết thúc một cách an toàn.
    Phân tích kết quả:
    Hàm fullName vẫn panic như trước.
    Tuy nhiên, hàm defer trong handleFullName đã được thực thi.
    Bên trong defer, recover() đã bắt được giá trị của panic (chuỗi "runtime error: last name cannot be nil").
    Chương trình đã không bị crash. Thay vào đó, nó in ra thông báo lỗi và tiếp tục thực thi, in ra dòng "Chương trình chính đã kết thúc...".